import openai
import csv
import time
# Установите ваш API-ключ OpenAI
openai.api_key = "_api_"

# Путь к CSV-файлу, в котором будут сохраняться ответы
csv_file_path = "obogrev100v5.csv"

# Инициализация CSV файла
with open(csv_file_path, 'w', newline='') as csvfile:
    csvwriter = csv.writer(csvfile)
    csvwriter.writerow(["Cycle", "Prompt", "Response"])

# Количество циклов
num_cycles = 40

# Инициализация счётчика циклов
cycle_count = 0

# Ваш prompt
prompt = """Пожалуйста, создайте текстовое описание для объявления продукта о 'Кварцевых обогревателях'. Опишите преимущества продукции, включите ключевые характеристики и покажите, как они могут сделать жизнь клиентов легче. Также подчеркните, что мы предлагаем продукты оптом и ищем партнеров для сотрудничества. Используйте креативные эмоджи и сделайте его максимально привлекательным для потенциальных покупателей."""

default_suffix = """<p><strong>Модель стандарт:</strong></p>
    <ul><li>1 шт - 1900 рублей</li><li>10 шт - 1700 рублей за штуку</li>
    <li>20 шт - 1500 рублей за штуку</li><li>40 шт - 1300 рублей за штуку</li>
    </ul>
    <p><strong>Модель 3D:</strong></p><ul><li>1 шт - 2300 рублей</li>
    <li>5 шт - 2100 рублей за штуку</li><li>10 шт - 1900 рублей за штуку</li>
    <li>20 шт - 1700 рублей за штуку</li><li>40 шт - 1500 рублей за штуку</li>
    </ul>
    <p>Важная информация о продукте:</p><ul>
    <li>Обогреваемый объем воздуха (при минимальных теплопотерях) составляет 20-24 м3 (10-12 м2) при высоте потолков 2,5 м.</li>
    <li>Номинальная мощность обогревателя составляет 0.48-0.5 кВт. Он быстро нагревает излучающую поверхность до температуры выше 75°C, и можно использовать таймерную розетку, чтобы снизить расход потребляемой энергии с 0.48 кВт/ч до 0.25 кВт/ч.</li><li>Гарантийный срок составляет 1 год с момента покупки, а срок службы от 10 до 25 лет с момента ввода в эксплуатацию.</li></ul><p>Комплектация включает в себя:</p><ul><li>Кварцевый обогреватель</li>
    <li>Настенный кронштейн (3 штуки)</li><li>Инструкция</li><li>Коробка 78x40x10 вес 12кг</li></ul><p>Продукт предоставляет дополнительное отопление, экономичен в использовании, и может использоваться для обогрева помещений.</p> 
    <p>Работаем с физическими и юридическими лицами.</p> <p>кварцевые обогреватели, тепловые пушки, масляные радиаторы, отопление, обогрев помещений, инфракрасные обогреватели, электрические обогреватели, дополнительное отопление, экономичные обогреватели, коммерческие обогреватели, обогреватель оптом, кварцевые нагреватели, масляные обогреватели, тепловое оборудование, отопление гаража, кварцевые обогреватели Валберис, тепловые пушки оптом, обогреватель с таймером, товары для маркетплейса, оптовая продажа обогревателей, радиаторы для обогрева, быстрые обогреватели, керамические обогреватели, купить обогреватель, недорогие обогреватели, тепловые устройства, обогреватель для бизнеса, промышленное отопление, кварцевые обогреватели оптом, маркетплейс товары, продажа обогревателей, обогреватель для офиса, магазин обогревателей, эффективное отопление, обогреватель для дома, энергосберегающие обогреватели, тепловые установки, оптовые цены на обогреватели, покупка обогревателей, инфракрасные обогреватели оптом, масляный радиатор для отопления, обогреватель с дистанционным управлением, купить обогреватель оптом, промышленные обогреватели.</p>"""

while cycle_count < num_cycles:
    # Задержка между запросами (например, 2 секунды)
    delay_seconds = 2
    time.sleep(delay_seconds)

    # Отправка запроса к модели
    completion = openai.ChatCompletion.create(
        model="gpt-3.5-turbo-16k-0613",
        messages=[
            {"role": "system", "content": "Сделай текст на русском языке пожалуйста. Спасибо! Ты супер! Текст в стиле лучших спикеров!"},
            {"role": "user", "content": prompt}
        ]
    )
    
    # Получение и вывод ответа модели
    response = completion['choices'][0]['message']['content'].strip()

    # Разделяем текст на строки, предполагая, что каждая строка - это отдельный абзац
    paragraphs = response.split("\n")

    # Создаем HTML-разметку, добавляя тег <p> только к непустым строкам
    html_text = "\n".join([f"<p>{paragraph}</p>" for paragraph in paragraphs if paragraph.strip()])    # Добавление строки по умолчанию
    response = html_text
    response += default_suffix



    print(f"Cycle {cycle_count + 1}, Response: {response}")
    
    # Сохранение ответа в CSV файл
    with open(csv_file_path, 'a', newline='') as csvfile:
        csvwriter = csv.writer(csvfile)
        csvwriter.writerow([cycle_count + 1, prompt, response])
    
    # Инкремент счётчика
    cycle_count += 1
